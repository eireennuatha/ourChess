개발 노트.

● 2012년 9월 24일.

해당 블록이 공격받는 블록인지 검사하는 함수를 만들었다. 매 턴이 끝날 때마다 턴을 받는 클라이언트가 이 함수를 호출해서 체크 당했는지 검사한다. 캐슬링을 시도할 때도 킹과 룩 사이의 블록들에 대해 이 함수를 호출함으로써 캐슬링이 가능한지 판단하게 했다. 대충 보기에도 코드에 비효율적인 부분이 있고, 버그가 있을 지도 모르는데, 피곤하니 나중에 봐야겠다. 아직 구현 못한 부분은 체크메이트 상태인지 확인하는 것과 폰의 앙 파상인데, 체크메이트 상태 확인하는 부분은 아직 깜깜하다. 

체크메이트인지 확인하는데 검사해야할 요소들을 떠오르는대로 써보자면,

1. 체크 당했을 때 맨 먼저 킹 주변의 8개 블록에 대해 킹이 이동할 수 있는지 확인해야 한다. 움직일 수 있으면 체크메이트가 아니다.
2. 다른 기물로 수비할 수 있는지 확인해야 한다. 체크를 외친 적 기물과 킹 사이의 블록들 중 하나라도 아군 기물의 공격범위 안에 있는지(수비가 가능한지) 확인한다.
3. 만약 있다면, 수비를 위해 해당 기물을 움직임으로써 혹시 또다른 적 기물에 의해 킹이 공격에 노출되지는 않는지 확인해야 한다.
4. 만약 노출되지 않는다면 체크메이트가 아니다.
5. 노출된다면, 2번으로 돌아가 다시 적 기물과 킹 사이의 '같은 블록을 수비 가능한 다른 기물', 혹은 '다른 블록'에 대해 확인한다.
6. 모든 경우의 수를 보아도 공격을 피할 수 없으면 체크메이트이다.

이정도가 떠오른다. 역시 글로 쓰니까 정리가 된다.


● 2012년 9월 23일. 

오늘 소스를 처음으로 git에 업로드하면서 일지를 작성하려고 한다. 개발을 시작한 8월 말부터 지금까지의 일들을 오늘 몰아서 적는다. 이후의 일은 차차 새로 쓸 것이다.

8월 말, 휴학 후 뭐라도 만들어볼까 하는 참에 멀티 플랫폼 체스게임을 떠올리게 되었다. 체스게임은 현실적으로 내 힘으로 만들어 볼만 한 목표 중 하나였다. 내가 가장 중요하게 생각한 부분은 데스크탑, 스마트폰, 태블릿PC를 아우르는 멀티 플랫폼 지원이었는데, 가장 쉬운 방법이 웹을 기반으로 만드는 것이라고 생각해서 웹 기반으로 개발을 시작하게 되었다.

처음엔 서버에 대한 생각은 거의 하지 않았다. 막연하게, 조금 알고있는 자바 지식으로 구글 앱 엔진 기반의 서버를 만들면 될 것이라고 생각했었고, 일단 클라이언트 측 구현에만 신경을 썼다. 다른 웹 기반 체스게임들을 많이 찾아봤는데, 나는 구식 기술보단 최신 기술에 큰 애착을 느끼는 사람이기 때문에 HTML5에서 새로 생긴 기술들을 중점으로 찾아보았다.

단순히 HTML의 table 엘리먼트를 8x8 사이즈로 만들어서 체스를 구현한 것도 있었고, 플래시를 이용한 것, HTML5 캔버스를 이용한 것, 심지어 WebGL을 이용한 것도 있었다. table로 구현하더라도 HTML5에서 새로 추가된 네이티브 드래그 앤 드롭 API를 사용하면 기물을 자연스럽게 이동할 수 있겠다 싶었다. 그러나 '내가 드래그하는 모습을 상대방도 볼 수 있으면 어떨까' 하는 욕심이 들어 table과 HTML5 네이티브 DND 기술은 배제했다. 플래시의 경우, 이미 안드로이드에서도 지원이 끊긴 기술이라 당연히 배제했고. WebGL은 아직 지원하는 브라우저가 적고, 3D로 짜기엔 너무 어려워보여 배제하였다. 결국 HTML5 캔버스가 남았는데, 매우 괜찮았다. 캔버스로 만든 체스게임들을 보면 드래그도 매우 자연스러웠고, 그래픽 효과도 좋아보였다. 모바일에서도 캔버스를 지원해서 브라우저가 있어서 멀티 플랫폼을 지원하는데 문제가 없다. ie8 이하 버전에서는 캔버스가 제대로 동작하지 않는 모양인데, 구식 브라우저는 지원할 계획이 없다.
 
HTML5 캔버스로 구현하기로 마음먹고 일단 캔버스와 자바스크립트 관련 서적들을 구매했다. 자바스크립트는 입문서 한권 훑다 만 정도의 지식밖에 없었기 때문에 이렇게나 많이 샀다.
  
HTML5 Canvas (ISBN-13:9788979148985), 자바스크립트 쿡북 (ISBN-13:ISBN-13:9788979148985), 자바스크립트 성능 최적화 (ISBN-13:9788979148558), 자바스크립트 코딩 기법과 핵심 패턴 (ISBN-13:9788966260157),

책을 참고해서 Canvas에 체스판을 그리고, 기물을 그릴 수 있었다. 기물 이미지는 위키피디아 체스 문서에서 퍼왔다. 처음 당면한 문제는 드래그 앤 드롭을 구현하는 것이었다. 플래시같은 기본적으로 캔버스에 한번 그려진 것은 드래그 할 수가 없다. 캔버스가 그래픽을 표현하는 방식을 즉시 모드라고 부르는 모양이다. 플래시, SVG, 실버라이트는 보류 모드로 그래픽을 표현하기 때문에 드래그를 논리적으로 구현할 수 있는 것 같다. 그래서 캔버스로 만들어진 다른 체스게임(https://www.valilchess.com/chess.html) 의 소스를 적극적으로 참고하려고 노력하였다. 이렇게 완성된 하나의 어플리케이션 소스를 분석해 보는 것이 처음이라 여기에 쓰인 테크닉들을 이해하는 데만도 많은 지식이 필요했다. 

결국 어떤 방식으로 드래그 앤 드롭을 구현했는지 이해했다. 기본 체스판을 그리는 캔버스와는 별도로, 드래그되는 기물을 표현하는 작은 캔버스를 하나 더 만드는 것이었다. mousedown 이벤트가 발생하면 이벤트가 발생한 좌표에 있는 기물을 기본 체스판 캔버스에서 지우고(체스판 색깔로 덮어씌우고), 다른 작은 캔버스의 visibility라는 css 속성을 변경해 나타나게 하고 거기에 해당 기물을 그리는 것이다. mousedown 이벤트가 발생하면 visibility를 변경해 다시 감추고... 그런데 이런 것을 구현하려면 체스판 위의 기물들에 대한 상태를 가지고 있어야 한다. 그래서 2차원 배열을 써서 8행 8열의 체스판 위의 기물을 정보를 가지는 배열을 만들었다. 드래그 앤 드롭이 이루어지면 그에 맞게 배열 값도 변화하게 하였다. 이렇게 기타 여러 테크닉을 써서  자연스럽고 논리적인 드래그 앤 드롭을 구현할 수 있었다. 스마트폰 같은 터치 디바이스에서는 mouse 이벤트 대신에 touch 이벤트가 있어서 문제였는데, 다행히 touch 이벤트를 mouse 이벤트로 핸들링하는 소스를 구글에서 찾아서 그대로 가져다 썼다. ^^; 나중에 이 소스도 분석해봐야겠다.

이제 드래그 앤 드롭도 구현했으니, 기물들이 움직이는 룰을 만들어야 했다. mousedown 이벤트가 발생했을 때 마우스가 체스판 안에 있었는지, 드래그 할 기물이 내 기물인지, 내 기물이라면 어떤 기물인지, mouseup 이벤트가 발생했을 때 이 좌표에 드랍할 수 있는 기물인지 등등 많은 룰 유효성 검사 함수들을 작성했다. 여기에선 백(White)의 입장에서 고려된 룰이었기 때문에, 흑의 입장에선 또 어떻게 할지 고민이었다. 흑의 입장에서는 체스판이 뒤집어진 모양인데, 이 함수들을 그대로 사용할 수 있을지 확신이 없었다. 이때는 상대방에게 데이터를 어떻게 전달할 지 감조차 없었기 때문에, 일단은 그냥 백의 입장에서만 생각하기로 하고 넘어갔다. 아직 완성 못한 룰도 몇가지 있다. 캐슬링을 시도할 때, 킹과 룩 사이에 공격받는 타일이 없어야 하는데 그걸 감지해낼 방법에 대한 아이디어가 아직 없고, 체크 받았을 때 체크를 피할 움직임만 허용되게 하여야 하는데 그또한 아직 아이디어가 없다. 또, 체크메이트를 감지하지도 못한다. 이때 당시에는 서버가 없는 상태였기 때문에 이부분은 서버를 완성한 후에 구현하려고 생각했었다.

이제 드래그 앤 드롭도 구현했고, 게임 룰도 어느정도 완성했으니 서버를 개발할 차례다. 클라이언트를 개발하면서 서버에 대한 몇몇 조건을 생각해봤는데, 첫째로 웹소켓을 지원하는 서버여야 하고, 둘째로 내가 돈이 없기 때문에 무료 호스팅을 할 수 있는 서버여야 한다는 것이다. 첫째 조건의 이유는, 상대방이 드래그하는 모습을 보게 하려면 mousemove 이벤트동안 마우스 좌표를 계속 서버를 거쳐서 상대방 클라이언트로 전송해야 하는데, 비동기 방식의 웹소켓이 아니면 통신 오버헤드가 너무 클 것 같아서다. 나는 구글 앱 엔진/자바 버전을 가장 선호했는데, 알아보니 구글 앱 엔진은 웹소켓을 지원하는 대신 Channel API라는 것을 지원하는데, 내부적으로는 비동기 방식의 연결이라고 한다. 이 Channel API를 배워보려고 깔짝대봤는데 자바 서버 개발 경험도 없고 관련 문서도 많지 않아서 결국 포기했다. 나중에 가능하다면 구글 앱 엔진/Go 버전으로 포팅해보고 싶다. 결국 차선책으로 Node.js를 쓰기로 했다. 이놈은 예전에 책 한권(모던 웹을 위한 Node.js 프로그래밍, ISBN-13:9788979148886) 사서 훑어본 적이 있어서 그나마 익숙했고, 자바스크립트를 쓰는 서버라서 클라이언트와 통일감(?)도 느껴져서 편안했다. 무엇보다 socket.io라는 npm(Node Packaged Modules)이 있다는게 큰 장점이다. socket.io는 웹소켓을 포함한 여러 통신 기술들을 더 쓰기 편하게 추상화하여 제공한 API이다. room 같은 기능도 제공하여 쓰기 아주 좋다.

서버 개발은 예전에 산 책의 예제 소스 중 '실시간 온라인 그림판' 예제를 뼈대삼아 시작했다. 이 예제는 로비 페이지에서 방을 생성해서 입장하는 로직으로 만들어져 있다. 방 이름을 입력해서 방을 생성하는 기존 로직을 살짝 바꿔, 방 생성 버튼을 누르면 랜덤 문자열이 생성되고, 이 문자열을 URL로 하는 방이 만들어지게 하였다. 이 방식은 내가 즐겨하던 pool 게임(http://www.omgpop.com/#/arcade) 에서 가져왔다. 방을 생성한 사람이 백을 쥐고, 해당 URL을 공유하여 그 다음으로 입장하는 사람이 흑, 그 다음으로 입장하는 사람들은 게스트로 여기게 하였다. 누가 백을 쥘지 흑을 쥘지는 나중에 선택가능하게 고치고 싶은 부분이다.

23일인 지금은 서버도 거의 완성 단계에 다다랐다. 게임은 대략 다음과 같이 이루어진다. 예를 들어 백이 어떤 기물을 드래그 앤 드롭 할 때, 백의 화면은 스스로가 캔버스를 변화시켜 드래그되는 모습을 보고, 다른 클라이언트들은 백에게서 서버를 거쳐 전달받은 데이터를 가지고 캔버스를 변화시킨다. 게스트들은 백의 입장에서 경기를 보게 되는데, 백의 움직임을 게스트들이 볼 때는 별 과정을 거치지 않지만 백의 움직임을 흑이 볼 때나, 흑의 움직임을 게스트가 볼 때는 진짜 반대편에서 상대방이 기물을 드래그하는 것 처럼 보이게 하기 위해 데이터들을 가공해서 사용하게 된다. 

이제 캐슬링, 체크, 체크메이트 같은 룰을 마저 완성하는 일. 화면이 작은 모바일 환경에서 체스판 사이즈가 더 자연스럽게 바뀌게 하는 일, 아직 못 찾아낸 버그 잡는 일 등이 남았다. 저 마지막 룰들을 완성시키는게 가장 큰 일이다. 그 다음엔 호스팅을 해야 하는데, node.js와 웹소켓을 무료로 지원하는 업체들을 찾아보니 썩 마음에 드는 곳이 별로 없다. 지금은 윈도 애저를 눈으로 찍어놨는데, 아직 확실하진 않다. 윈도 애저는 3개월 무료 호스팅을 지원하는 모양이다. 로비와 방을 더 화려하게 꾸미는 것은 맨 나중의 일로 미루려고 한다.